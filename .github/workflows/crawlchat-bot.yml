name: CrawlChat Bot

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]
  discussion:
    types: [created]
  discussion_comment:
    types: [created]

permissions:
  issues: write
  discussions: write
  contents: read

jobs:
  answer:
    if: >
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'discussion' && github.event.action == 'created') ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@crawlchat') &&
       github.event.comment.user.login != 'github-actions[bot]') ||
      (github.event_name == 'discussion_comment' &&
       contains(github.event.comment.body, '@crawlchat') &&
       github.event.comment.user.login != 'github-actions[bot]')
    runs-on: ubuntu-latest

    steps:
      - name: Check if bot already responded
        id: check_response
        run: |
          if [ "${{ github.event_name }}" == "issues" ] || [ "${{ github.event_name }}" == "issue_comment" ]; then
            # Get all comments on the issue
            COMMENTS=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "${{ github.event.issue.comments_url }}")
          else
            # Get all comments on the discussion
            COMMENTS=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/discussions/${{ github.event.discussion.number }}/comments")
          fi

          # Extract HTTP status and response body
          HTTP_STATUS=$(echo "$COMMENTS" | grep "HTTP_STATUS:" | cut -d: -f2)
          COMMENTS_BODY=$(echo "$COMMENTS" | sed '/HTTP_STATUS:/d')

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Failed to fetch comments, HTTP status: $HTTP_STATUS"
            # If we can't check, assume no response to be safe
            echo "already_responded=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if any comment contains our bot marker
          if echo "$COMMENTS_BODY" | jq -e '.[] | select(.body | contains("ðŸ¤– CrawlChat Answer"))' > /dev/null 2>&1; then
            echo "Bot already responded"
            echo "already_responded=true" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "Bot has not responded yet"
            echo "already_responded=false" >> $GITHUB_OUTPUT
          fi

      - name: Call CrawlChat Answer API
        if: steps.check_response.outputs.already_responded == 'false'
        id: api_call
        run: |
          # Extract the question from the issue/discussion body or comment
          if [ "${{ github.event_name }}" == "issues" ]; then
            QUESTION="${{ github.event.issue.title }} ${{ github.event.issue.body }}"
          elif [ "${{ github.event_name }}" == "discussion" ]; then
            QUESTION="${{ github.event.discussion.title }} ${{ github.event.discussion.body }}"
          else
            QUESTION="${{ github.event.comment.body }}"
          fi

          # Remove @crawlchat mention from question and clean up
          QUESTION=$(printf '%s' "$QUESTION" | sed 's/@crawlchat//g' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

          if [ ${#QUESTION} -gt 2000 ]; then
            echo "Question too long, truncating to 2000 characters"
            QUESTION="${QUESTION:0:2000}"
          fi

          # Escape special characters for JSON
          QUESTION_JSON=$(printf '%s' "$QUESTION" | jq -R -s '.')

          # Log sanitized question (remove newlines and limit length for security)
          QUESTION_LOG=$(printf '%s' "$QUESTION" | tr '\n' ' ' | cut -c1-200)
          echo "Question (sanitized): $QUESTION_LOG"

          # Call the CrawlChat Answer API
          RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST "${{ secrets.CRAWLCHAT_API_HOST }}/answer/${{ secrets.CRAWLCHAT_COLLECTION_ID }}" \
            -H "x-api-key: ${{ secrets.CRAWLCHAT_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{\"query\": $QUESTION_JSON}")

          # Extract HTTP status and response body
          HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d')

          echo "HTTP Status: $HTTP_STATUS"

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "API request failed with status: $HTTP_STATUS"
            # Log error response for debugging (limit to first 500 chars)
            ERROR_PREVIEW=$(echo "$RESPONSE_BODY" | cut -c1-500)
            echo "Error response: $ERROR_PREVIEW"
            exit 1
          fi

          # Extract the content from the response
          ANSWER=$(echo "$RESPONSE_BODY" | jq -r '.content')

          if [ "$ANSWER" == "null" ] || [ -z "$ANSWER" ]; then
            echo "Failed to get answer from API response - content field missing or empty"
            # Log response structure for debugging (without sensitive content)
            echo "Response structure: $(echo "$RESPONSE_BODY" | jq 'keys' 2>/dev/null || echo 'invalid json')"
            exit 1
          fi

          # Use multiline output format for GitHub Actions to handle newlines safely
          {
            echo "answer<<EOF"
            echo "$ANSWER"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Post comment with answer
        if: steps.check_response.outputs.already_responded == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const answer = `${{ steps.api_call.outputs.answer }}`;

            const body = 'ðŸ¤– **CrawlChat Answer**\n\n' + answer + '\n\n---\n*This answer was generated by CrawlChat AI based on our documentation.*';

            const eventName = '${{ github.event_name }}';

            if (eventName === 'issues' || eventName === 'issue_comment') {
              // Post comment on issue
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            } else {
              // Post comment on discussion
              await github.rest.discussions.createComment({
                discussion_number: ${{ github.event.discussion.number }},
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }